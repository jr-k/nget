#!/bin/sh

# nget - Expose files temporarily via HTTP for easy download
# Runs on Alpine Linux with minimal dependencies (nget-server, curl)

# Trap Ctrl+C and propagate to children
trap 'exit 130' INT TERM

# Check dependencies
if ! command -v nget-server >/dev/null 2>&1; then
    echo "Error: nget-server not found. Run inside the nget Docker container."
    exit 1
fi

NGET_DIR="/tmp/nget"
NGET_STATE="$NGET_DIR/state"
NGET_WWW="$NGET_DIR/www"
DEFAULT_EXPIRATION=600  # 10 minutes in seconds
PORT_START=33000
PORT_END=33100

# Colors for output (using actual escape sequences)
ESC=$(printf '\033')
RED="${ESC}[0;31m"
GREEN="${ESC}[0;32m"
YELLOW="${ESC}[1;33m"
CYAN="${ESC}[0;36m"
GRAY="${ESC}[1;30m"
NC="${ESC}[0m"

usage() {
    echo "Usage: nget [COMMAND] [OPTIONS] [FILE]"
    echo ""
    echo "Expose files from a Docker container via temporary HTTP links for easy download."
    echo ""
    echo "Commands:"
    echo "  ls                 List active sessions"
    echo "  kill <id|uuid>     Kill a session by ID or UUID"
    echo "  prune              Kill all active sessions"
    echo ""
    echo "Options:"
    echo "  -e <seconds>       Expiration time (default: 600 = 10 min)"
    echo ""
    echo "Examples:"
    echo "  nget myfile.txt         Expose for 10 minutes"
    echo "  nget -e 60 myfile.txt   Expose for 1 minute"
    echo "  nget myfolder/          Tar and expose folder"
    echo "  nget ls                 List active sessions"
    echo "  nget kill 1             Kill session #1"
    echo "  nget prune              Kill all sessions"
}

init_dirs() {
    mkdir -p "$NGET_STATE" "$NGET_WWW"
}

generate_uuid() {
    # Generate UUID using /proc/sys/kernel/random/uuid or fallback
    if [ -f /proc/sys/kernel/random/uuid ]; then
        cat /proc/sys/kernel/random/uuid
    else
        # Fallback: use date + random
        date +%s%N | sha256sum | head -c 32
        echo "-$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' ')"
    fi
}

get_public_ip() {
    # Try multiple services to get public IP (with short timeouts)
    ip=$(curl -s -m 2 ifconfig.me 2>/dev/null) && [ -n "$ip" ] && echo "$ip" && return
    ip=$(curl -s -m 2 ipinfo.io/ip 2>/dev/null) && [ -n "$ip" ] && echo "$ip" && return
    ip=$(curl -s -m 2 icanhazip.com 2>/dev/null) && [ -n "$ip" ] && echo "$ip" && return
    echo ""
}

get_local_ips() {
    # Get all IPs from all interfaces (BusyBox compatible)
    ip -4 addr show 2>/dev/null | grep 'inet ' | sed 's/.*inet \([0-9.]*\).*/\1/' | sort -u || \
    ifconfig 2>/dev/null | grep 'inet ' | sed 's/.*inet \(addr:\)\?\([0-9.]*\).*/\2/' | sort -u || \
    hostname -I 2>/dev/null | tr ' ' '\n' | grep -v '^$' | sort -u
}

find_free_port() {
    for port in $(seq $PORT_START $PORT_END); do
        if ! netstat -tuln 2>/dev/null | grep -q ":$port " && \
           ! ss -tuln 2>/dev/null | grep -q ":$port "; then
            # Double check no nget is using this port
            if ! grep -l "^PORT=$port$" "$NGET_STATE"/*.state 2>/dev/null | head -1 | grep -q .; then
                echo "$port"
                return 0
            fi
        fi
    done
    echo ""
    return 1
}

cleanup_expired() {
    now=$(date +%s)
    for statefile in "$NGET_STATE"/*.state; do
        [ -f "$statefile" ] || continue
        . "$statefile"
        if [ "$now" -ge "$EXPIRES" ]; then
            kill_session "$(basename "$statefile" .state)" quiet
        fi
    done
}

kill_session() {
    local id="$1"
    local quiet="$2"

    # Find by numeric ID or UUID
    if echo "$id" | grep -qE '^[0-9]+$'; then
        # Numeric ID - find the nth state file (oldest first)
        statefile=$(ls -1tr "$NGET_STATE"/*.state 2>/dev/null | sed -n "${id}p")
    else
        # UUID
        statefile="$NGET_STATE/$id.state"
    fi

    if [ ! -f "$statefile" ]; then
        [ -z "$quiet" ] && printf "%b\n" "${RED}Session not found: $id${NC}"
        return 1
    fi

    . "$statefile"

    # Kill the HTTP server (try SIGTERM first, then SIGKILL)
    if [ -n "$PID" ]; then
        if kill -0 "$PID" 2>/dev/null; then
            kill -TERM "$PID" 2>/dev/null || true
            sleep 0.3
            # Force kill if still running
            if kill -0 "$PID" 2>/dev/null; then
                kill -KILL "$PID" 2>/dev/null || true
            fi
        fi
    fi

    # Clean up files
    rm -rf "$NGET_WWW/$UUID"
    rm -f "$statefile"

    [ -z "$quiet" ] && printf "%b\n" "${GREEN}Killed session: $UUID${NC}"
}

prune_sessions() {
    local count=0
    for statefile in $(ls -1tr "$NGET_STATE"/*.state 2>/dev/null); do
        [ -f "$statefile" ] || continue
        kill_session "$(basename "$statefile" .state)" quiet
        count=$((count + 1))
    done
    if [ "$count" -eq 0 ]; then
        printf "%b\n" "${YELLOW}No active sessions to kill${NC}"
    else
        printf "%b\n" "${GREEN}Killed $count session(s)${NC}"
    fi
}

format_remaining() {
    local seconds="$1"
    if [ "$seconds" -lt 0 ]; then
        echo "expired"
    elif [ "$seconds" -lt 60 ]; then
        echo "${seconds}s"
    elif [ "$seconds" -lt 3600 ]; then
        echo "$((seconds / 60))m $((seconds % 60))s"
    else
        echo "$((seconds / 3600))h $((seconds % 3600 / 60))m"
    fi
}

list_sessions() {
    cleanup_expired

    local count=0
    local now=$(date +%s)
    local public_ip=$(get_public_ip)
    local local_ips=$(get_local_ips)

    for statefile in $(ls -1tr "$NGET_STATE"/*.state 2>/dev/null); do
        [ -f "$statefile" ] || continue
        count=$((count + 1))

        . "$statefile"
        remaining=$((EXPIRES - now))
        remaining_fmt=$(format_remaining $remaining)

        # Truncate filename if too long
        filename=$(basename "$FILEPATH")
        if [ ${#filename} -gt 40 ]; then
            filename="...$(echo "$filename" | tail -c 38)"
        fi

        echo ""
        printf "%b\n" "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        printf "%b\n" "${GREEN}#${count}${NC} ${YELLOW}$filename${NC}"
        printf "%b\n" "${GRAY}UUID: $UUID${NC} | ${GRAY}Port: $PORT${NC} | ${GRAY}Expires in: ${NC}${YELLOW}$remaining_fmt${NC}"
        echo ""
        printf "%b\n" "  ${CYAN}Download URLs:${NC}"
        if [ -n "$public_ip" ]; then
            printf "%b\n" "    ${GREEN}[public]${NC} http://${public_ip}:${PORT}/${UUID}"
        fi
        for ip in $local_ips; do
            [ "$ip" = "127.0.0.1" ] && continue
            printf "%b\n" "    ${CYAN}[local]${NC}  http://${ip}:${PORT}/${UUID}"
        done
    done

    if [ "$count" -eq 0 ]; then
        echo ""
        printf "%b\n" "${YELLOW}No active nget sessions${NC}"
    else
        echo ""
        printf "%b\n" "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo "Total: $count active session(s)"
    fi
    echo ""
}

start_server() {
    local uuid="$1"
    local port="$2"
    local filepath="$3"
    local expiration="$4"
    local is_tar="$5"

    local www_dir="$NGET_WWW/$uuid"
    mkdir -p "$www_dir"

    # Prepare the file
    if [ "$is_tar" = "true" ]; then
        local tarname="$(basename "$filepath").tar.gz"
        tar -czf "$www_dir/$uuid" -C "$(dirname "$filepath")" "$(basename "$filepath")"
        local serve_file="$www_dir/$uuid"
        local download_name="$tarname"
    else
        local serve_file="$filepath"
        local download_name="$(basename "$filepath")"
    fi

    local expires=$(($(date +%s) + expiration))

    # Start Go HTTP server in background
    nget-server -port "$port" -file "$serve_file" -uuid "$uuid" -name "$download_name" -expire "$expiration" >/dev/null 2>&1 &
    local pid=$!

    # Save state
    cat > "$NGET_STATE/$uuid.state" << EOF
UUID=$uuid
PORT=$port
FILEPATH=$filepath
EXPIRES=$expires
PID=$pid
IS_TAR=$is_tar
DOWNLOAD_NAME=$download_name
EOF

    echo "$pid"
}

nget_file() {
    local filepath="$1"
    local expiration="${2:-$DEFAULT_EXPIRATION}"

    # Resolve to absolute path
    filepath=$(cd "$(dirname "$filepath")" && pwd)/$(basename "$filepath")

    if [ ! -e "$filepath" ]; then
        printf "%b\n" "${RED}Error: File or directory not found: $filepath${NC}"
        exit 1
    fi

    init_dirs
    cleanup_expired

    local uuid=$(generate_uuid)
    local port=$(find_free_port)

    if [ -z "$port" ]; then
        printf "%b\n" "${RED}Error: No free port available in range $PORT_START-$PORT_END${NC}"
        exit 1
    fi

    local is_tar="false"
    local filename=$(basename "$filepath")

    if [ -d "$filepath" ]; then
        is_tar="true"
        filename="${filename}.tar.gz"
    fi

    local pid=$(start_server "$uuid" "$port" "$filepath" "$expiration" "$is_tar")
    local public_ip=$(get_public_ip)
    local local_ips=$(get_local_ips)

    echo ""
    printf "%b\n" "${GREEN}File exposed successfully!${NC}"
    echo ""
    printf "%b\n" "  ${CYAN}UUID:${NC}       $uuid"
    printf "%b\n" "  ${CYAN}File:${NC}       $(basename "$filepath")$([ "$is_tar" = "true" ] && echo " (tar.gz)")"
    printf "%b\n" "  ${CYAN}Port:${NC}       $port"
    printf "%b\n" "  ${CYAN}Expires in:${NC} $(format_remaining $expiration)"
    echo ""
    printf "%b\n" "${YELLOW}Download URLs:${NC}"

    # Show public IP first if available
    if [ -n "$public_ip" ]; then
        printf "%b\n" "  ${GREEN}[public]${NC}  http://${public_ip}:${port}/${uuid}"
    fi

    # Show all local IPs
    for ip in $local_ips; do
        if [ "$ip" = "127.0.0.1" ]; then
            printf "%b\n" "  ${CYAN}[lo]${NC}      http://${ip}:${port}/${uuid}"
        else
            printf "%b\n" "  ${CYAN}[local]${NC}   http://${ip}:${port}/${uuid}"
        fi
    done

    echo ""
    printf "%b\n" "${YELLOW}Copy-paste commands:${NC}"
    echo ""

    # wget section
    printf "%b" "  ${GRAY}# wget${NC}"
    if [ -n "$public_ip" ]; then
        printf "%b\n" "  ${GREEN}[public]${NC} wget -O '$filename' 'http://${public_ip}:${port}/${uuid}'"
    fi
    for ip in $local_ips; do
        [ "$ip" = "127.0.0.1" ] && continue
        printf "%b\n" "  ${CYAN}[local]${NC}  wget -O '$filename' 'http://${ip}:${port}/${uuid}'"
    done

    printf "%b\n"

    # curl section
    printf "%b" "  ${GRAY}# curl${NC}"
    if [ -n "$public_ip" ]; then
        printf "%b\n" "  ${GREEN}[public]${NC} curl -o '$filename' 'http://${public_ip}:${port}/${uuid}'"
    fi
    for ip in $local_ips; do
        [ "$ip" = "127.0.0.1" ] && continue
        printf "%b\n" "  ${CYAN}[local]${NC}  curl -o '$filename' 'http://${ip}:${port}/${uuid}'"
    done
    echo ""
}

# Main
init_dirs

# Handle commands first
case "${1:-}" in
    ls)
        list_sessions
        exit 0
        ;;
    kill)
        if [ -z "${2:-}" ]; then
            printf "%b\n" "${RED}Usage: nget kill <id|uuid>${NC}"
            exit 1
        fi
        kill_session "$2"
        exit 0
        ;;
    prune)
        prune_sessions
        exit 0
        ;;
esac

# Parse options for file sharing
EXPIRATION=$DEFAULT_EXPIRATION

while getopts "e:" opt; do
    case $opt in
        e)
            EXPIRATION=$OPTARG
            ;;
        *)
            usage
            exit 1
            ;;
    esac
done

shift $((OPTIND - 1))

if [ $# -eq 0 ]; then
    usage
    list_sessions
    exit 0
fi

nget_file "$1" "$EXPIRATION"
